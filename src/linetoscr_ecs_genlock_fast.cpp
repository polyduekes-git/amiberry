/*
* UAE - The portable Amiga emulator.
*
* This file was generated by genlinetoscr. Don't edit.
*/

static void lts_ecs_n_ilores_dlores_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			col = xcolors[colors_ocs[c]];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_dpf_ilores_dlores_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			{
				uae_u8 dpval = dpf_lookup[c];
				col = xcolors[colors_ocs[dpval]];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_ehb_ilores_dlores_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			c &= bplehb_mask;
			if (c <= 31) {
				col = xcolors[colors_ocs[c]];
			} else {
				col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_ham_ilores_dlores_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			col = decode_ham_pixel_fast(c, colors_ocs);
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_kehb_ilores_dlores_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			col = xcolors[colors_ocs[c & 31]];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_n_ihires_dlores_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			col = xcolors[colors_ocs[c]];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_dpf_ihires_dlores_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			{
				uae_u8 dpval = dpf_lookup[c];
				col = xcolors[colors_ocs[dpval]];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_ehb_ihires_dlores_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			c &= bplehb_mask;
			if (c <= 31) {
				col = xcolors[colors_ocs[c]];
			} else {
				col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_ham_ihires_dlores_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			col = decode_ham_pixel_fast(c, colors_ocs);
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_kehb_ihires_dlores_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			col = xcolors[colors_ocs[c & 31]];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_n_ishres_dlores_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_ecs_dpf_ishres_dlores_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_ecs_ehb_ishres_dlores_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_ecs_ham_ishres_dlores_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_ecs_kehb_ishres_dlores_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_ecs_n_ilores_dhires_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					gbuf += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = xcolors[colors_ocs[c]];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			col = xcolors[colors_ocs[c]];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_dpf_ilores_dhires_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					gbuf += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			{
				uae_u8 dpval = dpf_lookup[c];
				col = xcolors[colors_ocs[dpval]];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			{
				uae_u8 dpval = dpf_lookup[c];
				col = xcolors[colors_ocs[dpval]];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_ehb_ilores_dhires_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					gbuf += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c &= bplehb_mask;
			if (c <= 31) {
				col = xcolors[colors_ocs[c]];
			} else {
				col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			c &= bplehb_mask;
			if (c <= 31) {
				col = xcolors[colors_ocs[c]];
			} else {
				col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_ham_ilores_dhires_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					gbuf += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = decode_ham_pixel_fast(c, colors_ocs);
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			col = decode_ham_pixel_fast(c, colors_ocs);
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_kehb_ilores_dhires_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					gbuf += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = xcolors[colors_ocs[c & 31]];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			col = xcolors[colors_ocs[c & 31]];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_n_ihires_dhires_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			col = xcolors[colors_ocs[c]];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_dpf_ihires_dhires_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			{
				uae_u8 dpval = dpf_lookup[c];
				col = xcolors[colors_ocs[dpval]];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_ehb_ihires_dhires_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			c &= bplehb_mask;
			if (c <= 31) {
				col = xcolors[colors_ocs[c]];
			} else {
				col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_ham_ihires_dhires_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			col = decode_ham_pixel_fast(c, colors_ocs);
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_kehb_ihires_dhires_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			col = xcolors[colors_ocs[c & 31]];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_n_ishres_dhires_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c0 = *cp++;
			uae_u8 c1 = *cp++;
			uae_u32 dpix_val0, dpix_val1;
			uae_u8 gpix0, gpix1;
			get_shres_pix_genlock(c0, c1, &dpix_val0, &dpix_val1, &gpix0, &gpix1);
			*buf1++ = dpix_val0;
			*gbuf++ = gpix0;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_dpf_ishres_dhires_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c0 = *cp++;
			uae_u8 c1 = *cp++;
			uae_u32 dpix_val0, dpix_val1;
			uae_u8 gpix0, gpix1;
			get_shres_pix_genlock(c0, c1, &dpix_val0, &dpix_val1, &gpix0, &gpix1);
			*buf1++ = dpix_val0;
			*gbuf++ = gpix0;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_ehb_ishres_dhires_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c0 = *cp++;
			uae_u8 c1 = *cp++;
			uae_u32 dpix_val0, dpix_val1;
			uae_u8 gpix0, gpix1;
			get_shres_pix_genlock(c0, c1, &dpix_val0, &dpix_val1, &gpix0, &gpix1);
			*buf1++ = dpix_val0;
			*gbuf++ = gpix0;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_ham_ishres_dhires_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c0 = *cp++;
			uae_u8 c1 = *cp++;
			uae_u32 dpix_val0, dpix_val1;
			uae_u8 gpix0, gpix1;
			get_shres_pix_genlock(c0, c1, &dpix_val0, &dpix_val1, &gpix0, &gpix1);
			*buf1++ = dpix_val0;
			*gbuf++ = gpix0;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_kehb_ishres_dhires_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c0 = *cp++;
			uae_u8 c1 = *cp++;
			uae_u32 dpix_val0, dpix_val1;
			uae_u8 gpix0, gpix1;
			get_shres_pix_genlock(c0, c1, &dpix_val0, &dpix_val1, &gpix0, &gpix1);
			*buf1++ = dpix_val0;
			*gbuf++ = gpix0;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_n_ilores_dshres_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 4;
					gbuf += 4;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = xcolors[colors_ocs[c]];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = xcolors[colors_ocs[c]];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = xcolors[colors_ocs[c]];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			col = xcolors[colors_ocs[c]];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_dpf_ilores_dshres_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 4;
					gbuf += 4;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			{
				uae_u8 dpval = dpf_lookup[c];
				col = xcolors[colors_ocs[dpval]];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			{
				uae_u8 dpval = dpf_lookup[c];
				col = xcolors[colors_ocs[dpval]];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			{
				uae_u8 dpval = dpf_lookup[c];
				col = xcolors[colors_ocs[dpval]];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			{
				uae_u8 dpval = dpf_lookup[c];
				col = xcolors[colors_ocs[dpval]];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_ehb_ilores_dshres_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 4;
					gbuf += 4;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c &= bplehb_mask;
			if (c <= 31) {
				col = xcolors[colors_ocs[c]];
			} else {
				col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			c &= bplehb_mask;
			if (c <= 31) {
				col = xcolors[colors_ocs[c]];
			} else {
				col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			c &= bplehb_mask;
			if (c <= 31) {
				col = xcolors[colors_ocs[c]];
			} else {
				col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			c &= bplehb_mask;
			if (c <= 31) {
				col = xcolors[colors_ocs[c]];
			} else {
				col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_ham_ilores_dshres_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 4;
					gbuf += 4;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = decode_ham_pixel_fast(c, colors_ocs);
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = decode_ham_pixel_fast(c, colors_ocs);
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = decode_ham_pixel_fast(c, colors_ocs);
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			col = decode_ham_pixel_fast(c, colors_ocs);
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_kehb_ilores_dshres_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 4;
					gbuf += 4;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = xcolors[colors_ocs[c & 31]];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = xcolors[colors_ocs[c & 31]];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = xcolors[colors_ocs[c & 31]];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			col = xcolors[colors_ocs[c & 31]];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_n_ihires_dshres_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					gbuf += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = xcolors[colors_ocs[c]];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			col = xcolors[colors_ocs[c]];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_dpf_ihires_dshres_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					gbuf += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			{
				uae_u8 dpval = dpf_lookup[c];
				col = xcolors[colors_ocs[dpval]];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			{
				uae_u8 dpval = dpf_lookup[c];
				col = xcolors[colors_ocs[dpval]];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_ehb_ihires_dshres_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					gbuf += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c &= bplehb_mask;
			if (c <= 31) {
				col = xcolors[colors_ocs[c]];
			} else {
				col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			c &= bplehb_mask;
			if (c <= 31) {
				col = xcolors[colors_ocs[c]];
			} else {
				col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_ham_ihires_dshres_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					gbuf += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = decode_ham_pixel_fast(c, colors_ocs);
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			col = decode_ham_pixel_fast(c, colors_ocs);
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_kehb_ihires_dshres_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					gbuf += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = xcolors[colors_ocs[c & 31]];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			col = xcolors[colors_ocs[c & 31]];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_n_ishres_dshres_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c0 = *cp++;
			uae_u8 c1 = *cp++;
			uae_u32 dpix_val0, dpix_val1;
			uae_u8 gpix0, gpix1;
			get_shres_pix_genlock(c0, c1, &dpix_val0, &dpix_val1, &gpix0, &gpix1);
			*buf1++ = dpix_val0;
			*buf1++ = dpix_val1;
			*gbuf++ = gpix0;
			*gbuf++ = gpix1;
			cnt += bufaddv;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_dpf_ishres_dshres_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c0 = *cp++;
			uae_u8 c1 = *cp++;
			uae_u32 dpix_val0, dpix_val1;
			uae_u8 gpix0, gpix1;
			get_shres_pix_genlock(c0, c1, &dpix_val0, &dpix_val1, &gpix0, &gpix1);
			*buf1++ = dpix_val0;
			*buf1++ = dpix_val1;
			*gbuf++ = gpix0;
			*gbuf++ = gpix1;
			cnt += bufaddv;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_ehb_ishres_dshres_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c0 = *cp++;
			uae_u8 c1 = *cp++;
			uae_u32 dpix_val0, dpix_val1;
			uae_u8 gpix0, gpix1;
			get_shres_pix_genlock(c0, c1, &dpix_val0, &dpix_val1, &gpix0, &gpix1);
			*buf1++ = dpix_val0;
			*buf1++ = dpix_val1;
			*gbuf++ = gpix0;
			*gbuf++ = gpix1;
			cnt += bufaddv;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_ham_ishres_dshres_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c0 = *cp++;
			uae_u8 c1 = *cp++;
			uae_u32 dpix_val0, dpix_val1;
			uae_u8 gpix0, gpix1;
			get_shres_pix_genlock(c0, c1, &dpix_val0, &dpix_val1, &gpix0, &gpix1);
			*buf1++ = dpix_val0;
			*buf1++ = dpix_val1;
			*gbuf++ = gpix0;
			*gbuf++ = gpix1;
			cnt += bufaddv;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_kehb_ishres_dshres_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c0 = *cp++;
			uae_u8 c1 = *cp++;
			uae_u32 dpix_val0, dpix_val1;
			uae_u8 gpix0, gpix1;
			get_shres_pix_genlock(c0, c1, &dpix_val0, &dpix_val1, &gpix0, &gpix1);
			*buf1++ = dpix_val0;
			*buf1++ = dpix_val1;
			*gbuf++ = gpix0;
			*gbuf++ = gpix1;
			cnt += bufaddv;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_n_ilores_dlores_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			col = xcolors[colors_ocs[c]];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_dpf_ilores_dlores_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			{
				uae_u8 dpval = dpf_lookup[c];
				col = xcolors[colors_ocs[dpval]];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_ehb_ilores_dlores_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			c &= bplehb_mask;
			if (c <= 31) {
				col = xcolors[colors_ocs[c]];
			} else {
				col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_ham_ilores_dlores_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			col = decode_ham_pixel_fast(c, colors_ocs);
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_kehb_ilores_dlores_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			col = xcolors[colors_ocs[c & 31]];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_n_ihires_dlores_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			col = xcolors[colors_ocs[c]];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_dpf_ihires_dlores_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			{
				uae_u8 dpval = dpf_lookup[c];
				col = xcolors[colors_ocs[dpval]];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_ehb_ihires_dlores_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			c &= bplehb_mask;
			if (c <= 31) {
				col = xcolors[colors_ocs[c]];
			} else {
				col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_ham_ihires_dlores_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			col = decode_ham_pixel_fast(c, colors_ocs);
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_kehb_ihires_dlores_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			col = xcolors[colors_ocs[c & 31]];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_n_ishres_dlores_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_ecs_dpf_ishres_dlores_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_ecs_ehb_ishres_dlores_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_ecs_ham_ishres_dlores_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_ecs_kehb_ishres_dlores_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	lts_null();
}
static void lts_ecs_n_ilores_dhires_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					buf2 += 2;
					gbuf += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = xcolors[colors_ocs[c]];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			col = xcolors[colors_ocs[c]];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_dpf_ilores_dhires_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					buf2 += 2;
					gbuf += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			{
				uae_u8 dpval = dpf_lookup[c];
				col = xcolors[colors_ocs[dpval]];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			{
				uae_u8 dpval = dpf_lookup[c];
				col = xcolors[colors_ocs[dpval]];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_ehb_ilores_dhires_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					buf2 += 2;
					gbuf += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c &= bplehb_mask;
			if (c <= 31) {
				col = xcolors[colors_ocs[c]];
			} else {
				col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			c &= bplehb_mask;
			if (c <= 31) {
				col = xcolors[colors_ocs[c]];
			} else {
				col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_ham_ilores_dhires_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					buf2 += 2;
					gbuf += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = decode_ham_pixel_fast(c, colors_ocs);
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			col = decode_ham_pixel_fast(c, colors_ocs);
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_kehb_ilores_dhires_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					buf2 += 2;
					gbuf += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = xcolors[colors_ocs[c & 31]];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			col = xcolors[colors_ocs[c & 31]];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_n_ihires_dhires_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			col = xcolors[colors_ocs[c]];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_dpf_ihires_dhires_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			{
				uae_u8 dpval = dpf_lookup[c];
				col = xcolors[colors_ocs[dpval]];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_ehb_ihires_dhires_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			c &= bplehb_mask;
			if (c <= 31) {
				col = xcolors[colors_ocs[c]];
			} else {
				col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_ham_ihires_dhires_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			col = decode_ham_pixel_fast(c, colors_ocs);
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_kehb_ihires_dhires_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			col = xcolors[colors_ocs[c & 31]];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_n_ishres_dhires_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c0 = *cp++;
			uae_u8 c1 = *cp++;
			uae_u32 dpix_val0, dpix_val1;
			uae_u8 gpix0, gpix1;
			get_shres_pix_genlock(c0, c1, &dpix_val0, &dpix_val1, &gpix0, &gpix1);
			*buf1++ = dpix_val0;
			*buf2++ = dpix_val0;
			*gbuf++ = gpix0;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_dpf_ishres_dhires_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c0 = *cp++;
			uae_u8 c1 = *cp++;
			uae_u32 dpix_val0, dpix_val1;
			uae_u8 gpix0, gpix1;
			get_shres_pix_genlock(c0, c1, &dpix_val0, &dpix_val1, &gpix0, &gpix1);
			*buf1++ = dpix_val0;
			*buf2++ = dpix_val0;
			*gbuf++ = gpix0;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_ehb_ishres_dhires_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c0 = *cp++;
			uae_u8 c1 = *cp++;
			uae_u32 dpix_val0, dpix_val1;
			uae_u8 gpix0, gpix1;
			get_shres_pix_genlock(c0, c1, &dpix_val0, &dpix_val1, &gpix0, &gpix1);
			*buf1++ = dpix_val0;
			*buf2++ = dpix_val0;
			*gbuf++ = gpix0;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_ham_ishres_dhires_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c0 = *cp++;
			uae_u8 c1 = *cp++;
			uae_u32 dpix_val0, dpix_val1;
			uae_u8 gpix0, gpix1;
			get_shres_pix_genlock(c0, c1, &dpix_val0, &dpix_val1, &gpix0, &gpix1);
			*buf1++ = dpix_val0;
			*buf2++ = dpix_val0;
			*gbuf++ = gpix0;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_kehb_ishres_dhires_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c0 = *cp++;
			uae_u8 c1 = *cp++;
			uae_u32 dpix_val0, dpix_val1;
			uae_u8 gpix0, gpix1;
			get_shres_pix_genlock(c0, c1, &dpix_val0, &dpix_val1, &gpix0, &gpix1);
			*buf1++ = dpix_val0;
			*buf2++ = dpix_val0;
			*gbuf++ = gpix0;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_n_ilores_dshres_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 4;
					buf2 += 4;
					gbuf += 4;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = xcolors[colors_ocs[c]];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = xcolors[colors_ocs[c]];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = xcolors[colors_ocs[c]];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			col = xcolors[colors_ocs[c]];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_dpf_ilores_dshres_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 4;
					buf2 += 4;
					gbuf += 4;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			{
				uae_u8 dpval = dpf_lookup[c];
				col = xcolors[colors_ocs[dpval]];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			{
				uae_u8 dpval = dpf_lookup[c];
				col = xcolors[colors_ocs[dpval]];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			{
				uae_u8 dpval = dpf_lookup[c];
				col = xcolors[colors_ocs[dpval]];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			{
				uae_u8 dpval = dpf_lookup[c];
				col = xcolors[colors_ocs[dpval]];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_ehb_ilores_dshres_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 4;
					buf2 += 4;
					gbuf += 4;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c &= bplehb_mask;
			if (c <= 31) {
				col = xcolors[colors_ocs[c]];
			} else {
				col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			c &= bplehb_mask;
			if (c <= 31) {
				col = xcolors[colors_ocs[c]];
			} else {
				col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			c &= bplehb_mask;
			if (c <= 31) {
				col = xcolors[colors_ocs[c]];
			} else {
				col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			c &= bplehb_mask;
			if (c <= 31) {
				col = xcolors[colors_ocs[c]];
			} else {
				col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_ham_ilores_dshres_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 4;
					buf2 += 4;
					gbuf += 4;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = decode_ham_pixel_fast(c, colors_ocs);
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = decode_ham_pixel_fast(c, colors_ocs);
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = decode_ham_pixel_fast(c, colors_ocs);
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			col = decode_ham_pixel_fast(c, colors_ocs);
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_kehb_ilores_dshres_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 4;
					buf2 += 4;
					gbuf += 4;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = xcolors[colors_ocs[c & 31]];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = xcolors[colors_ocs[c & 31]];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = xcolors[colors_ocs[c & 31]];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			col = xcolors[colors_ocs[c & 31]];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_n_ihires_dshres_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					buf2 += 2;
					gbuf += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = xcolors[colors_ocs[c]];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			col = xcolors[colors_ocs[c]];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_dpf_ihires_dshres_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					buf2 += 2;
					gbuf += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			{
				uae_u8 dpval = dpf_lookup[c];
				col = xcolors[colors_ocs[dpval]];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			{
				uae_u8 dpval = dpf_lookup[c];
				col = xcolors[colors_ocs[dpval]];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_ehb_ihires_dshres_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					buf2 += 2;
					gbuf += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			c &= bplehb_mask;
			if (c <= 31) {
				col = xcolors[colors_ocs[c]];
			} else {
				col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			c &= bplehb_mask;
			if (c <= 31) {
				col = xcolors[colors_ocs[c]];
			} else {
				col = xcolors[(colors_ocs[c - 32] >> 1) & 0x777];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_ham_ihires_dshres_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					buf2 += 2;
					gbuf += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = decode_ham_pixel_fast(c, colors_ocs);
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			col = decode_ham_pixel_fast(c, colors_ocs);
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_kehb_ihires_dshres_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					buf2 += 2;
					gbuf += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			clxdat |= bplcoltable[c];
			col = xcolors[colors_ocs[c & 31]];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
			c = *cp;
			clxdat |= bplcoltable[c];
			cp += cpaddv;
			col = xcolors[colors_ocs[c & 31]];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(c);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_n_ishres_dshres_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c0 = *cp++;
			uae_u8 c1 = *cp++;
			uae_u32 dpix_val0, dpix_val1;
			uae_u8 gpix0, gpix1;
			get_shres_pix_genlock(c0, c1, &dpix_val0, &dpix_val1, &gpix0, &gpix1);
			*buf1++ = dpix_val0;
			*buf1++ = dpix_val1;
			*buf2++ = dpix_val0;
			*buf2++ = dpix_val1;
			*gbuf++ = gpix0;
			*gbuf++ = gpix1;
			cnt += bufaddv;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_dpf_ishres_dshres_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c0 = *cp++;
			uae_u8 c1 = *cp++;
			uae_u32 dpix_val0, dpix_val1;
			uae_u8 gpix0, gpix1;
			get_shres_pix_genlock(c0, c1, &dpix_val0, &dpix_val1, &gpix0, &gpix1);
			*buf1++ = dpix_val0;
			*buf1++ = dpix_val1;
			*buf2++ = dpix_val0;
			*buf2++ = dpix_val1;
			*gbuf++ = gpix0;
			*gbuf++ = gpix1;
			cnt += bufaddv;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_ehb_ishres_dshres_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c0 = *cp++;
			uae_u8 c1 = *cp++;
			uae_u32 dpix_val0, dpix_val1;
			uae_u8 gpix0, gpix1;
			get_shres_pix_genlock(c0, c1, &dpix_val0, &dpix_val1, &gpix0, &gpix1);
			*buf1++ = dpix_val0;
			*buf1++ = dpix_val1;
			*buf2++ = dpix_val0;
			*buf2++ = dpix_val1;
			*gbuf++ = gpix0;
			*gbuf++ = gpix1;
			cnt += bufaddv;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_ham_ishres_dshres_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c0 = *cp++;
			uae_u8 c1 = *cp++;
			uae_u32 dpix_val0, dpix_val1;
			uae_u8 gpix0, gpix1;
			get_shres_pix_genlock(c0, c1, &dpix_val0, &dpix_val1, &gpix0, &gpix1);
			*buf1++ = dpix_val0;
			*buf1++ = dpix_val1;
			*buf2++ = dpix_val0;
			*buf2++ = dpix_val1;
			*gbuf++ = gpix0;
			*gbuf++ = gpix1;
			cnt += bufaddv;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_ecs_kehb_ishres_dshres_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u16 *colors_ocs = (uae_u16*)ls->linecolorstate;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u8 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hbstop_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c0 = *cp++;
			uae_u8 c1 = *cp++;
			uae_u32 dpix_val0, dpix_val1;
			uae_u8 gpix0, gpix1;
			get_shres_pix_genlock(c0, c1, &dpix_val0, &dpix_val1, &gpix0, &gpix1);
			*buf1++ = dpix_val0;
			*buf1++ = dpix_val1;
			*buf2++ = dpix_val0;
			*buf2++ = dpix_val1;
			*gbuf++ = gpix0;
			*gbuf++ = gpix1;
			cnt += bufaddv;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static LINETOSRC_FUNCF linetoscr_ecs_genlock_fast_funcs[] = {
	lts_ecs_n_ilores_dlores_b1_genlock,
	lts_ecs_dpf_ilores_dlores_b1_genlock,
	lts_ecs_ehb_ilores_dlores_b1_genlock,
	lts_ecs_ham_ilores_dlores_b1_genlock,
	lts_ecs_kehb_ilores_dlores_b1_genlock,
	lts_ecs_n_ihires_dlores_b1_genlock,
	lts_ecs_dpf_ihires_dlores_b1_genlock,
	lts_ecs_ehb_ihires_dlores_b1_genlock,
	lts_ecs_ham_ihires_dlores_b1_genlock,
	lts_ecs_kehb_ihires_dlores_b1_genlock,
	lts_ecs_n_ishres_dlores_b1_genlock,
	lts_ecs_dpf_ishres_dlores_b1_genlock,
	lts_ecs_ehb_ishres_dlores_b1_genlock,
	lts_ecs_ham_ishres_dlores_b1_genlock,
	lts_ecs_kehb_ishres_dlores_b1_genlock,
	lts_ecs_n_ilores_dhires_b1_genlock,
	lts_ecs_dpf_ilores_dhires_b1_genlock,
	lts_ecs_ehb_ilores_dhires_b1_genlock,
	lts_ecs_ham_ilores_dhires_b1_genlock,
	lts_ecs_kehb_ilores_dhires_b1_genlock,
	lts_ecs_n_ihires_dhires_b1_genlock,
	lts_ecs_dpf_ihires_dhires_b1_genlock,
	lts_ecs_ehb_ihires_dhires_b1_genlock,
	lts_ecs_ham_ihires_dhires_b1_genlock,
	lts_ecs_kehb_ihires_dhires_b1_genlock,
	lts_ecs_n_ishres_dhires_b1_genlock,
	lts_ecs_dpf_ishres_dhires_b1_genlock,
	lts_ecs_ehb_ishres_dhires_b1_genlock,
	lts_ecs_ham_ishres_dhires_b1_genlock,
	lts_ecs_kehb_ishres_dhires_b1_genlock,
	lts_ecs_n_ilores_dshres_b1_genlock,
	lts_ecs_dpf_ilores_dshres_b1_genlock,
	lts_ecs_ehb_ilores_dshres_b1_genlock,
	lts_ecs_ham_ilores_dshres_b1_genlock,
	lts_ecs_kehb_ilores_dshres_b1_genlock,
	lts_ecs_n_ihires_dshres_b1_genlock,
	lts_ecs_dpf_ihires_dshres_b1_genlock,
	lts_ecs_ehb_ihires_dshres_b1_genlock,
	lts_ecs_ham_ihires_dshres_b1_genlock,
	lts_ecs_kehb_ihires_dshres_b1_genlock,
	lts_ecs_n_ishres_dshres_b1_genlock,
	lts_ecs_dpf_ishres_dshres_b1_genlock,
	lts_ecs_ehb_ishres_dshres_b1_genlock,
	lts_ecs_ham_ishres_dshres_b1_genlock,
	lts_ecs_kehb_ishres_dshres_b1_genlock,
	lts_ecs_n_ilores_dlores_b2_genlock,
	lts_ecs_dpf_ilores_dlores_b2_genlock,
	lts_ecs_ehb_ilores_dlores_b2_genlock,
	lts_ecs_ham_ilores_dlores_b2_genlock,
	lts_ecs_kehb_ilores_dlores_b2_genlock,
	lts_ecs_n_ihires_dlores_b2_genlock,
	lts_ecs_dpf_ihires_dlores_b2_genlock,
	lts_ecs_ehb_ihires_dlores_b2_genlock,
	lts_ecs_ham_ihires_dlores_b2_genlock,
	lts_ecs_kehb_ihires_dlores_b2_genlock,
	lts_ecs_n_ishres_dlores_b2_genlock,
	lts_ecs_dpf_ishres_dlores_b2_genlock,
	lts_ecs_ehb_ishres_dlores_b2_genlock,
	lts_ecs_ham_ishres_dlores_b2_genlock,
	lts_ecs_kehb_ishres_dlores_b2_genlock,
	lts_ecs_n_ilores_dhires_b2_genlock,
	lts_ecs_dpf_ilores_dhires_b2_genlock,
	lts_ecs_ehb_ilores_dhires_b2_genlock,
	lts_ecs_ham_ilores_dhires_b2_genlock,
	lts_ecs_kehb_ilores_dhires_b2_genlock,
	lts_ecs_n_ihires_dhires_b2_genlock,
	lts_ecs_dpf_ihires_dhires_b2_genlock,
	lts_ecs_ehb_ihires_dhires_b2_genlock,
	lts_ecs_ham_ihires_dhires_b2_genlock,
	lts_ecs_kehb_ihires_dhires_b2_genlock,
	lts_ecs_n_ishres_dhires_b2_genlock,
	lts_ecs_dpf_ishres_dhires_b2_genlock,
	lts_ecs_ehb_ishres_dhires_b2_genlock,
	lts_ecs_ham_ishres_dhires_b2_genlock,
	lts_ecs_kehb_ishres_dhires_b2_genlock,
	lts_ecs_n_ilores_dshres_b2_genlock,
	lts_ecs_dpf_ilores_dshres_b2_genlock,
	lts_ecs_ehb_ilores_dshres_b2_genlock,
	lts_ecs_ham_ilores_dshres_b2_genlock,
	lts_ecs_kehb_ilores_dshres_b2_genlock,
	lts_ecs_n_ihires_dshres_b2_genlock,
	lts_ecs_dpf_ihires_dshres_b2_genlock,
	lts_ecs_ehb_ihires_dshres_b2_genlock,
	lts_ecs_ham_ihires_dshres_b2_genlock,
	lts_ecs_kehb_ihires_dshres_b2_genlock,
	lts_ecs_n_ishres_dshres_b2_genlock,
	lts_ecs_dpf_ishres_dshres_b2_genlock,
	lts_ecs_ehb_ishres_dshres_b2_genlock,
	lts_ecs_ham_ishres_dshres_b2_genlock,
	lts_ecs_kehb_ishres_dshres_b2_genlock,
	NULL
};
