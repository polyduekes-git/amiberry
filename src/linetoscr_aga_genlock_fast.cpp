/*
* UAE - The portable Amiga emulator.
*
* This file was generated by genlinetoscr. Don't edit.
*/

static void lts_aga_n_ilores_dlores_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			col = colors_aga[c];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_dpf_ilores_dlores_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = colors_aga[dpval];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ehb_ilores_dlores_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = colors_aga[c];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ham_ilores_dlores_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_kehb_ilores_dlores_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			col = colors_aga[c & 31];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_n_ihires_dlores_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			col = colors_aga[c];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_dpf_ihires_dlores_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = colors_aga[dpval];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ehb_ihires_dlores_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = colors_aga[c];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ham_ihires_dlores_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_kehb_ihires_dlores_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			col = colors_aga[c & 31];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_n_ishres_dlores_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			col = colors_aga[c];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_dpf_ishres_dlores_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = colors_aga[dpval];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ehb_ishres_dlores_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = colors_aga[c];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ham_ishres_dlores_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_kehb_ishres_dlores_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			col = colors_aga[c & 31];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_n_ilores_dhires_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					gbuf += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			col = colors_aga[c];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[1];
			c ^= bxor;
			col = colors_aga[c];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_dpf_ilores_dhires_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					gbuf += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = colors_aga[dpval];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[1];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = colors_aga[dpval];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ehb_ilores_dhires_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					gbuf += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = colors_aga[c];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[1];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = colors_aga[c];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ham_ilores_dhires_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					gbuf += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[1];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_kehb_ilores_dhires_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					gbuf += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			col = colors_aga[c & 31];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[1];
			c ^= bxor;
			col = colors_aga[c & 31];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_n_ihires_dhires_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			col = colors_aga[c];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_dpf_ihires_dhires_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = colors_aga[dpval];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ehb_ihires_dhires_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = colors_aga[c];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ham_ihires_dhires_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_kehb_ihires_dhires_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			col = colors_aga[c & 31];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_n_ishres_dhires_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			col = colors_aga[c];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_dpf_ishres_dhires_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = colors_aga[dpval];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ehb_ishres_dhires_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = colors_aga[c];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ham_ishres_dhires_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_kehb_ishres_dhires_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			col = colors_aga[c & 31];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_n_ilores_dshres_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 4;
					gbuf += 4;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			col = colors_aga[c];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[1];
			c ^= bxor;
			col = colors_aga[c];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[2];
			c ^= bxor;
			col = colors_aga[c];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[3];
			c ^= bxor;
			col = colors_aga[c];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_dpf_ilores_dshres_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 4;
					gbuf += 4;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = colors_aga[dpval];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[1];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = colors_aga[dpval];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[2];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = colors_aga[dpval];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[3];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = colors_aga[dpval];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ehb_ilores_dshres_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 4;
					gbuf += 4;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = colors_aga[c];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[1];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = colors_aga[c];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[2];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = colors_aga[c];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[3];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = colors_aga[c];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ham_ilores_dshres_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 4;
					gbuf += 4;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[1];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[2];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[3];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_kehb_ilores_dshres_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 4;
					gbuf += 4;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			col = colors_aga[c & 31];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[1];
			c ^= bxor;
			col = colors_aga[c & 31];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[2];
			c ^= bxor;
			col = colors_aga[c & 31];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[3];
			c ^= bxor;
			col = colors_aga[c & 31];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_n_ihires_dshres_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					gbuf += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			col = colors_aga[c];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[1];
			c ^= bxor;
			col = colors_aga[c];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_dpf_ihires_dshres_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					gbuf += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = colors_aga[dpval];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[1];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = colors_aga[dpval];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ehb_ihires_dshres_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					gbuf += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = colors_aga[c];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[1];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = colors_aga[c];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ham_ihires_dshres_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					gbuf += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[1];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_kehb_ihires_dshres_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					gbuf += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			col = colors_aga[c & 31];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[1];
			c ^= bxor;
			col = colors_aga[c & 31];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_n_ishres_dshres_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			col = colors_aga[c];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_dpf_ishres_dshres_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = colors_aga[dpval];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ehb_ishres_dshres_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = colors_aga[c];
			}
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ham_ishres_dshres_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_kehb_ishres_dshres_b1_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			col = colors_aga[c & 31];
			*buf1++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_n_ilores_dlores_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			col = colors_aga[c];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_dpf_ilores_dlores_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = colors_aga[dpval];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ehb_ilores_dlores_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = colors_aga[c];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ham_ilores_dlores_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_kehb_ilores_dlores_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			col = colors_aga[c & 31];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_n_ihires_dlores_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			col = colors_aga[c];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_dpf_ihires_dlores_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = colors_aga[dpval];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ehb_ihires_dlores_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = colors_aga[c];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ham_ihires_dlores_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_kehb_ihires_dlores_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			col = colors_aga[c & 31];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_n_ishres_dlores_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			col = colors_aga[c];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_dpf_ishres_dlores_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = colors_aga[dpval];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ehb_ishres_dlores_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = colors_aga[c];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ham_ishres_dlores_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_kehb_ishres_dlores_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			col = colors_aga[c & 31];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_n_ilores_dhires_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					buf2 += 2;
					gbuf += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			col = colors_aga[c];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[1];
			c ^= bxor;
			col = colors_aga[c];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_dpf_ilores_dhires_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					buf2 += 2;
					gbuf += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = colors_aga[dpval];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[1];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = colors_aga[dpval];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ehb_ilores_dhires_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					buf2 += 2;
					gbuf += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = colors_aga[c];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[1];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = colors_aga[c];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ham_ilores_dhires_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					buf2 += 2;
					gbuf += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[1];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_kehb_ilores_dhires_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					buf2 += 2;
					gbuf += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			col = colors_aga[c & 31];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[1];
			c ^= bxor;
			col = colors_aga[c & 31];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_n_ihires_dhires_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			col = colors_aga[c];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_dpf_ihires_dhires_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = colors_aga[dpval];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ehb_ihires_dhires_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = colors_aga[c];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ham_ihires_dhires_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_kehb_ihires_dhires_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			col = colors_aga[c & 31];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_n_ishres_dhires_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			col = colors_aga[c];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_dpf_ishres_dhires_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = colors_aga[dpval];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ehb_ishres_dhires_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = colors_aga[c];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ham_ishres_dhires_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_kehb_ishres_dhires_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			col = colors_aga[c & 31];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_n_ilores_dshres_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 4;
					buf2 += 4;
					gbuf += 4;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			col = colors_aga[c];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[1];
			c ^= bxor;
			col = colors_aga[c];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[2];
			c ^= bxor;
			col = colors_aga[c];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[3];
			c ^= bxor;
			col = colors_aga[c];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_dpf_ilores_dshres_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 4;
					buf2 += 4;
					gbuf += 4;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = colors_aga[dpval];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[1];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = colors_aga[dpval];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[2];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = colors_aga[dpval];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[3];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = colors_aga[dpval];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ehb_ilores_dshres_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 4;
					buf2 += 4;
					gbuf += 4;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = colors_aga[c];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[1];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = colors_aga[c];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[2];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = colors_aga[c];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[3];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = colors_aga[c];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ham_ilores_dshres_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 4;
					buf2 += 4;
					gbuf += 4;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[1];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[2];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[3];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_kehb_ilores_dshres_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 4;
					buf2 += 4;
					gbuf += 4;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			col = colors_aga[c & 31];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[1];
			c ^= bxor;
			col = colors_aga[c & 31];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[2];
			c ^= bxor;
			col = colors_aga[c & 31];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[3];
			c ^= bxor;
			col = colors_aga[c & 31];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_n_ihires_dshres_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					buf2 += 2;
					gbuf += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			col = colors_aga[c];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[1];
			c ^= bxor;
			col = colors_aga[c];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_dpf_ihires_dshres_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					buf2 += 2;
					gbuf += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = colors_aga[dpval];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[1];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = colors_aga[dpval];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ehb_ihires_dshres_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					buf2 += 2;
					gbuf += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = colors_aga[c];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[1];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = colors_aga[c];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ham_ihires_dshres_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					buf2 += 2;
					gbuf += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[1];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_kehb_ihires_dshres_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1 += 2;
					buf2 += 2;
					gbuf += 2;
				} else {
					*buf1++ = bgcolor;
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			col = colors_aga[c & 31];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
			c = *cp;
			cp += cpadds[1];
			c ^= bxor;
			col = colors_aga[c & 31];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_n_ishres_dshres_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			col = colors_aga[c];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_dpf_ishres_dshres_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			{
				uae_u8 dpval = dpf_lookup[c];
				if (dpf_lookup_no[c]) {
					dpval += dblpfofs[bpldualpf2of];
				}
				dpval ^= bxor;
				col = colors_aga[dpval];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ehb_ishres_dshres_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			if (c & 0x20) {
				uae_u32 v = (colors_aga[c & 31] >> 1) & 0x7f7f7f;
				col = CONVERT_RGB(v);
			} else {
				col = colors_aga[c];
			}
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_ham_ishres_dshres_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			col = decode_ham_pixel_aga_fast(c, planes, bxor, colors_aga);
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static void lts_aga_kehb_ishres_dshres_b2_genlock(int draw_start, int draw_end, int draw_startoffset, int hbstrt_offset, int hbstop_offset, int hstrt_offset, int hstop_offset,int bpl1dat_trigger_offset, int planes, uae_u32 bgcolor, uae_u8 *cp, uae_u8 *cp2, int cpadd, int *cpadds, int bufadd, struct linestate *ls)
{
	uae_u32 *colors_aga = (uae_u32*)ls->linecolorstate;
	uae_u8 bxor = ls->bplcon4 >> 8;
	int bufaddv = 1 << bufadd;
	int cpaddv = 1 << cpadd;
	uae_u16 gpix = get_genlock_transparency_border_fast(ls->bplcon3);
	int end = draw_end;
	if (end > hbstrt_offset) {
		end = hbstrt_offset;
	}
	int cnt = draw_end;
	if (cnt > draw_startoffset) {
		cnt = draw_startoffset;
	}
	if (cnt > hbstop_offset) {
		cnt = hbstop_offset;
	}
	if (cnt > bpl1dat_trigger_offset) {
		cnt = bpl1dat_trigger_offset;
	}
	while (cnt < end) {
		bool bpl = false;
		if (cnt < bpl1dat_trigger_offset || cnt < hstrt_offset || cnt >= hstop_offset) {
			if (cnt >= draw_startoffset) {
				if (cnt < hbstop_offset) {
					buf1++;
					buf2++;
					gbuf++;
				} else {
					*buf1++ = bgcolor;
					*buf2++ = bgcolor;
					*gbuf++ = gpix;
				}
			}
		} else {
			bpl = true;
			uae_u8 c;
			uae_u32 col;
			c = *cp;
			cp += cpadds[0];
			c ^= bxor;
			col = colors_aga[c & 31];
			*buf1++ = col;
			*buf2++ = col;
			gpix = get_genlock_transparency_fast(col);
			*gbuf++ = gpix;
		}
		if (cnt >= bpl1dat_trigger_offset && !bpl) {
			cp += cpaddv;
		}
		cnt += bufaddv;
	}
}
static LINETOSRC_FUNCF linetoscr_aga_genlock_fast_funcs[] = {
	lts_aga_n_ilores_dlores_b1_genlock,
	lts_aga_dpf_ilores_dlores_b1_genlock,
	lts_aga_ehb_ilores_dlores_b1_genlock,
	lts_aga_ham_ilores_dlores_b1_genlock,
	lts_aga_kehb_ilores_dlores_b1_genlock,
	lts_aga_n_ihires_dlores_b1_genlock,
	lts_aga_dpf_ihires_dlores_b1_genlock,
	lts_aga_ehb_ihires_dlores_b1_genlock,
	lts_aga_ham_ihires_dlores_b1_genlock,
	lts_aga_kehb_ihires_dlores_b1_genlock,
	lts_aga_n_ishres_dlores_b1_genlock,
	lts_aga_dpf_ishres_dlores_b1_genlock,
	lts_aga_ehb_ishres_dlores_b1_genlock,
	lts_aga_ham_ishres_dlores_b1_genlock,
	lts_aga_kehb_ishres_dlores_b1_genlock,
	lts_aga_n_ilores_dhires_b1_genlock,
	lts_aga_dpf_ilores_dhires_b1_genlock,
	lts_aga_ehb_ilores_dhires_b1_genlock,
	lts_aga_ham_ilores_dhires_b1_genlock,
	lts_aga_kehb_ilores_dhires_b1_genlock,
	lts_aga_n_ihires_dhires_b1_genlock,
	lts_aga_dpf_ihires_dhires_b1_genlock,
	lts_aga_ehb_ihires_dhires_b1_genlock,
	lts_aga_ham_ihires_dhires_b1_genlock,
	lts_aga_kehb_ihires_dhires_b1_genlock,
	lts_aga_n_ishres_dhires_b1_genlock,
	lts_aga_dpf_ishres_dhires_b1_genlock,
	lts_aga_ehb_ishres_dhires_b1_genlock,
	lts_aga_ham_ishres_dhires_b1_genlock,
	lts_aga_kehb_ishres_dhires_b1_genlock,
	lts_aga_n_ilores_dshres_b1_genlock,
	lts_aga_dpf_ilores_dshres_b1_genlock,
	lts_aga_ehb_ilores_dshres_b1_genlock,
	lts_aga_ham_ilores_dshres_b1_genlock,
	lts_aga_kehb_ilores_dshres_b1_genlock,
	lts_aga_n_ihires_dshres_b1_genlock,
	lts_aga_dpf_ihires_dshres_b1_genlock,
	lts_aga_ehb_ihires_dshres_b1_genlock,
	lts_aga_ham_ihires_dshres_b1_genlock,
	lts_aga_kehb_ihires_dshres_b1_genlock,
	lts_aga_n_ishres_dshres_b1_genlock,
	lts_aga_dpf_ishres_dshres_b1_genlock,
	lts_aga_ehb_ishres_dshres_b1_genlock,
	lts_aga_ham_ishres_dshres_b1_genlock,
	lts_aga_kehb_ishres_dshres_b1_genlock,
	lts_aga_n_ilores_dlores_b2_genlock,
	lts_aga_dpf_ilores_dlores_b2_genlock,
	lts_aga_ehb_ilores_dlores_b2_genlock,
	lts_aga_ham_ilores_dlores_b2_genlock,
	lts_aga_kehb_ilores_dlores_b2_genlock,
	lts_aga_n_ihires_dlores_b2_genlock,
	lts_aga_dpf_ihires_dlores_b2_genlock,
	lts_aga_ehb_ihires_dlores_b2_genlock,
	lts_aga_ham_ihires_dlores_b2_genlock,
	lts_aga_kehb_ihires_dlores_b2_genlock,
	lts_aga_n_ishres_dlores_b2_genlock,
	lts_aga_dpf_ishres_dlores_b2_genlock,
	lts_aga_ehb_ishres_dlores_b2_genlock,
	lts_aga_ham_ishres_dlores_b2_genlock,
	lts_aga_kehb_ishres_dlores_b2_genlock,
	lts_aga_n_ilores_dhires_b2_genlock,
	lts_aga_dpf_ilores_dhires_b2_genlock,
	lts_aga_ehb_ilores_dhires_b2_genlock,
	lts_aga_ham_ilores_dhires_b2_genlock,
	lts_aga_kehb_ilores_dhires_b2_genlock,
	lts_aga_n_ihires_dhires_b2_genlock,
	lts_aga_dpf_ihires_dhires_b2_genlock,
	lts_aga_ehb_ihires_dhires_b2_genlock,
	lts_aga_ham_ihires_dhires_b2_genlock,
	lts_aga_kehb_ihires_dhires_b2_genlock,
	lts_aga_n_ishres_dhires_b2_genlock,
	lts_aga_dpf_ishres_dhires_b2_genlock,
	lts_aga_ehb_ishres_dhires_b2_genlock,
	lts_aga_ham_ishres_dhires_b2_genlock,
	lts_aga_kehb_ishres_dhires_b2_genlock,
	lts_aga_n_ilores_dshres_b2_genlock,
	lts_aga_dpf_ilores_dshres_b2_genlock,
	lts_aga_ehb_ilores_dshres_b2_genlock,
	lts_aga_ham_ilores_dshres_b2_genlock,
	lts_aga_kehb_ilores_dshres_b2_genlock,
	lts_aga_n_ihires_dshres_b2_genlock,
	lts_aga_dpf_ihires_dshres_b2_genlock,
	lts_aga_ehb_ihires_dshres_b2_genlock,
	lts_aga_ham_ihires_dshres_b2_genlock,
	lts_aga_kehb_ihires_dshres_b2_genlock,
	lts_aga_n_ishres_dshres_b2_genlock,
	lts_aga_dpf_ishres_dshres_b2_genlock,
	lts_aga_ehb_ishres_dshres_b2_genlock,
	lts_aga_ham_ishres_dshres_b2_genlock,
	lts_aga_kehb_ishres_dshres_b2_genlock,
	NULL
};
